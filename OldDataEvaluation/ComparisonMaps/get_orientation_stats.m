function orientation_stats = get_orientation_stats(data_obj,alpha,apply_filter)
%{
 orientation_stats = get_orientation_stats(data_obj,alpha,apply_filter)

 Function to calculate the confidence intervals of a map. For this
 multiple bootstrap samples of the map are generated and for each pixel
 the confidence intervals of orientation and selectivity are calculated.
 This function needs a data_handle class to obtain the different
 bootstrap samples.

 NEEDED CODE:
  bootstrap_ci = to calculate confidence intervals

 INPUT:
  data_obj = data class (generated by data_handle)
  alpha = distribution limits for confidence intervals (def 0.05)
  apply_filter = detemine if the samples are filtered (def true)

 OUTPUT:
  orientation_stats = 3D array, first 2D is the map size, the 3rd is [low_CI median high_CI]

 16/4/2014 chepe@nld.ds.mpg.de
 29/08/2017: Updated to corrected and accelerated boostrap CI
%}
%% read input

% boot_samples
num_boot_samples = size(data_obj.samples_array,3);

% confidence
if ~exist('confidence','var')
    alpha = 0.05;
else
    if isempty(alpha)
        alpha = 0.05;
    end
end

% filter maps
if ~exist('apply_filter','var')
    apply_filter = true;
else
    if isempty(alpha)
        apply_filter = true;
    end
end

%% prepare bootstrap samples

% get mean sample
stat = data_obj.read_map(1,true);

% get bootstrap samples
bootstat = zeros(sum(data_obj.ROI(:)),num_boot_samples);
for ii=1:num_boot_samples
    bootstat(:,ii) = data_obj.read_map(ii,true);
end

% get jackknife samples
samples_array = data_obj.samples_array;
data_obj.prepare_jackknife_samples;
jackstat = zeros(sum(data_obj.ROI(:)),data_obj.data_parameters.num_blocks);
for ii=1:data_obj.data_parameters.num_blocks
    jackstat(:,ii) = data_obj.read_map(ii,true);
end
data_obj.set_samples_array(samples_array);

% Filter the samples
if apply_filter
    stat = data_obj.filter_map(stat);    
    for ii=1:num_boot_samples
        bootstat(:,ii) = data_obj.filter_map(bootstat(:,ii));
    end    
    for ii=1:data_obj.data_parameters.num_blocks
        jackstat(:,ii) = data_obj.filter_map(jackstat(:,ii));
    end
end

%% calculate bootstrap CI's

% selectivity
sel_ci = bootstrap_ci(abs(bootstat),abs(stat),abs(jackstat),alpha);
% orientation
ori_ci = bootstrap_ci(bootstat,stat,jackstat,alpha);

%% generate output by converting back from vector to array

orientation_stats = cat(3,...
    data_obj.vector2array(sel_ci(:,1).*exp(1i*ori_ci(:,1))),...
    data_obj.vector2array(stat),...
    data_obj.vector2array(sel_ci(:,2).*exp(1i*ori_ci(:,2))));

end

%{

OLD VERSION!

%% create and fill 2D array with results,

% Each row is the pixel number and the column the sample number
disp('--- Obtaining bootstrap samples')
samplesArray = zeros(sum(obj.ROI(:)),num_boot_samples);
for ii=1:num_boot_samples
    if apply_filter
        samplesArray(:,ii) = obj.filter_map(obj.read_map(ii,true));
    else
        samplesArray(:,ii) = obj.read_map(ii,true);
    end
end

%% calculate confidence intervals of selectivity

% calculate CI boundaries
lo=max(int16(round(num_boot_samples*alpha/2)),1);
md = max(int16(round(num_boot_samples*.5)),1);
hi=int16(round(num_boot_samples*(1-alpha/2)));

selectivity = sort(abs(samplesArray),2);
selectivity = selectivity(:,[lo md hi]);

%% calculate confidence intervals of orientation
orientation = samplesArray./abs(samplesArray); % convert to --> exp(1i*orientation)
disp('--- Calculating confidence intervals')

% Circular statistics used:
% Take first sample as initial median and go through samples to find for
% each pixel the value that is closer to the median. The median value
% is the one where the sum of the angles using as zero reference is minimum

% summed the differences from the orientation of the first sample
summed_difference = [orientation(:,1),sum(abs(angle(bsxfun(@rdivide,orientation,orientation(:,1)))),2)];
for ii=2:num_boot_samples
    % summed the differences from the orientation of the current sample
    test_summed_difference = [orientation(:,ii),sum(abs(angle(bsxfun(@rdivide,orientation,orientation(:,ii)))),2)];
    % check pixel indices that are closer to the median and exchange
    idx = find(test_summed_difference(:,2)<summed_difference(:,2));
    summed_difference(idx,:)=test_summed_difference(idx,:);
end
% shift by median orientation to find CI
orientation = sort(angle(bsxfun(@rdivide,orientation,summed_difference(:,1))),2);
% shift back to original orientation
orientation = bsxfun(@times,exp(1i*orientation(:,[lo md hi])),summed_difference(:,1));

%% generate output by converting back from vector to array
map_CI = cat(3,...
    obj.vector2array(selectivity(:,1).*orientation(:,1)),...
    obj.vector2array(selectivity(:,2).*orientation(:,2)),...
    obj.vector2array(selectivity(:,3).*orientation(:,3)));
disp('--- Done')
%}
